target Python 

import FrostMachine from "../frost/src/lib/FrostMachine.lf"

reactor Cell4 extends FrostMachine{
    //VARIABLES
    state operation_running = {= self.data_model.get_node("Cell4/Cell_4_Robot_Coordinator_PLC/DataBlocksGlobal/DB_ROBOTS/plcOperationRunning")=}
    state operation_don = {= self.data_model.get_node("Cell4/Cell_4_Robot_Coordinator_PLC/DataBlocksGlobal/DB_ROBOTS/plcOperationDone")=}
    state operation_error = {= self.data_model.get_node("Cell4/Cell_4_Robot_Coordinator_PLC/DataBlocksGlobal/DB_ROBOTS/plcOperationError")=}
    state abb_prog_running = {= self.data_model.get_node("Cell4/Cell_4_Robot_Coordinator_PLC/DataBlocksGlobal/DB_ROBOTS/ABB/programRunning")=}
    state kuka_prog_running = {= self.data_model.get_node("Cell4/Cell_4_Robot_Coordinator_PLC/DataBlocksGlobal/DB_ROBOTS/KUKA/programRunning")=}
    state abb_positions = {= self.data_model.get_node("Cell4/Cell_4_Robot_Coordinator_PLC/DataBlocksGlobal/DB_BUFFER/ABBPositions")=}
    state kuka_positions = {= self.data_model.get_node("Cell4/Cell_4_Robot_Coordinator_PLC/DataBlocksGlobal/DB_BUFFER/KUKAPositions")=}
    //METHODS
    state clear_buffer = {= self.data_model.get_node("Cell4/Cell_4_Robot_Coordinator_PLC/DataBlocksInstance/OPC_UA_CLEAR_BUFFER_DB")=}
    state move_and_place = {= self.data_model.get_node("Cell4/Cell_4_Robot_Coordinator_PLC/DataBlocksInstance/OPC_UA_MOVE_AND_PLACE_DB")=}
    state move_over = {= self.data_model.get_node("Cell4/Cell_4_Robot_Coordinator_PLC/DataBlocksInstance/OPC_UA_MOVE_OVER_PALLET_DB")=}
    state pick_from_pallet = {= self.data_model.get_node("Cell4/Cell_4_Robot_Coordinator_PLC/DataBlocksInstance/OPC_UA_PICK_FROM_PALLET_DB")=}
    state place_to_pallet = {= self.data_model.get_node("Cell4/Cell_4_Robot_Coordinator_PLC/DataBlocksInstance/OPC_UA_PLACE_TO_PALLET_DB")=}
    state submit_robot_operation = {= self.data_model.get_node("Cell4/Cell_4_Robot_Coordinator_PLC/DataBlocksInstance/OPC_UA_SUBMIT_ROBOT_OPERATION_DB")=}
    state abb_pick_board = {= self.data_model.get_node("Cell4/Cell_4_Robot_Coordinator_PLC/DataBlocksInstance/OPC_UA_ABB_PICK_BOARD_FROM_PALLET_DB")=}
    state gadget_assembly = {= self.data_model.get_node("Cell4/Cell_4_Robot_Coordinator_PLC/DataBlocksInstance/OPC_UA_GADGET_ASSEMBLY_DB")=}

    logical action delay
    state handle_method = []

    reaction(startup)-> channel_out{=
        '''
        Initialize the Cell4 reactor, setting up the initial state and scheduling the first routine.
        It also sends a registration message to the communication channel.
        '''
        self.gadget_assembly.callback = lambda *args, **kwargs: True

    =}

    reaction(channel_in) -> delay, channel_out{=
        '''
        This reaction is triggered when a message is received on the channel_in.
        It processes the message and schedules a delay for further operations.
        '''
        for message in self.method_queue:
            if message.payload.node.split("/")[-1] == self.gadget_assembly.name:
                self.handle_method.append(message)
                self.method_queue.remove(message)
                delay.schedule(SEC(100), self.gadget_assembly.name)  # Simulate a delay for processing
                self.logger.info(f"Processing gadget assembly operation for {self.name}")
    =}  

    reaction(delay) -> channel_out{=
        '''
        This reaction is triggered after the delay set in the previous reaction.
        It processes the gadget assembly operation and sends a response message.
        The operation is identified by the name stored in the delay.
        If the operation matches the gadget assembly, it constructs a response message indicating success and sends it through the channel_out.
        If the operation does not match, it logs a warning.
        '''
        operation = delay.value
        if operation == self.gadget_assembly.name:
            message = self.protocol_mng.handle_request(self.handle_method.pop(0))
            channel_out[0].set(message)
        else:
            self.logger.warning(f"Unknown operation: {operation}")
    =}

}
