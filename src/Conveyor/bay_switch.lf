target Python

import FrostBase from "../../../frost/src/lib/FrostBase.lf"


reactor BaySwitch extends FrostBase{
    state conveyor_name

    reaction(startup){=
        temp = self.name.split(".")
        self.conveyor_name = temp[len(temp)-2] + "_" + temp[len(temp)-1]
    =}
    input from_back
    output to_back
    input from_forward
    output to_forward

    output to_frost

    input controller_command
    output ask_to_controller

    state pallet = {=None=}

    logical action unhandled_pallet

    reaction(unhandled_pallet) ->ask_to_controller, to_frost{=
        if self.pallet == None:
            raise Exception(f"Switch {self.conveyor_name} error: no pallet to handle")
        self._set_output_port([Events.pallet_arrived.value, self.pallet.id], to_frost)
        self.logger.debug(f"Switch {self.conveyor_name} waiting for controller to know what to do with {self.pallet.id}")
        ask_to_controller.set([Events.pallet_arrived, self.pallet.id, self.conveyor_name])
    =}

    logical action pending_pallet
    reaction(pending_pallet) -> pending_pallet, ask_to_controller{=
        if self.pallet == None:
            return 0
        self.logger.debug(f"Switch {self.conveyor_name} waiting for controller to know what to do with {self.pallet.id}")
        self._set_output_port([Events.pallet_pending, self.pallet.id, self.conveyor_name], ask_to_controller)
        pending_pallet.schedule(SEC(2))
    =}

    method pallet_in(value){=
        if not isinstance(value, Pallet):
            raise Exception(f"Error: Switch {self.conveyor_name} received non-pallet value: {value}")

        if self.pallet is not None:
            raise Exception(f"Error: Switch {self.conveyor_name} received {value.id} but already has a pallet.")

        self.logger.error(f"Switch {self.conveyor_name} received pallet {value.id}")

        self.pallet = value
    =}

    reaction(from_back)-> unhandled_pallet{=
        self.pallet_in(from_back.value[0])
        unhandled_pallet.schedule(0)
    =}

    reaction(from_forward)-> unhandled_pallet{=
        self.pallet_in(from_forward.value[0])
        unhandled_pallet.schedule(0)
    =}

    reaction(controller_command) -> ask_to_controller, to_forward, to_back, to_frost, pending_pallet{=
        '''
        controller_command format: [[header], [command], [args]]
            header = list of str with Segment names involved in the command
            command = [ControllerCommand, BayAction]
            args = additional arguments (if any)
        '''
        value = controller_command.value
        header = value[0]
        if self.conveyor_name not in header:
            return 0
    
        cmd = value[1][0]
        if not isinstance(cmd, ControllerCommand):
            raise Exception(f"Switch {self.conveyor_name} error: unknown command {cmd}")

        action_to_be_performed = value[1][1]
        if not isinstance(action_to_be_performed, BayAction):
            raise Exception(f"Switch {self.conveyor_name} error: unknown command {cmd}")

        if cmd == ControllerCommand.move:               
            if self.pallet is None:
                raise Exception(f"Switch {self.conveyor_name} error: no pallet to move")
            
            if action_to_be_performed == BayAction.back:
                self.logger.debug(f"Switch {self.conveyor_name} moving pallet {self.pallet.id} to previous switch")
                self._set_output_port(self.pallet, to_belt)
            elif action_to_be_performed == BayAction.forward:
                self.logger.debug(f"Switch {self.conveyor_name} moving pallet {self.pallet.id} to next switch")
                self._set_output_port(self.pallet, to_forward)
            elif action_to_be_performed == BayAction.none:
                self.logger.debug(f"Switch {self.conveyor_name} holding pallet {self.pallet.id}")
                pending_pallet.schedule(SEC(2))
            else:
                raise Exception(f"Switch {self.conveyor_name} error: unknown switch action {action_to_be_performed}")
            self._set_output_port([Events.pallet_released.value, self.pallet.id], to_frost)
            self._set_output_port([Events.pallet_released, self.pallet.id, self.conveyor_name], ask_to_controller)

            self.pallet = None

        elif cmd == ControllerCommand.release:
            if self.pallet is None:
                raise Exception(f"Switch {self.conveyor_name} error: no pallet to release")
            self.logger.debug(f"Switch {self.conveyor_name} releasing pallet {self.pallet.id}")
            self._set_output_port([Events.pallet_pending, self.pallet.id, self.conveyor_name], ask_to_controller)
    =}
}
