target Python{
    files: [
        source_folder/controller_utils.py,
        source_folder/pallet.py, 
        source_folder/routing_algorithm.py, 
        source_folder/bay_routing_algorithm.py,
        source_folder/interchange_scheduling.py,
        source_folder/utils.py
    ]
};

import FrostBase from "../../../frost/src/lib/FrostBase.lf"

preamble{=
    from pallet import Pallet
    from controller_utils import new_destination
    from interchange_scheduling import schedule_with_priority
    from bay_routing_algorithm import compute_bay_route, check_bay_available, leave_bay, update_bay_positions
    from routing_algorithm import calculate_next_action
    from utils import Events, SegmentAction, ControllerCommand, SwitchAction, SwitchName, InterchangeName, SegmentName, InterchangeInputs, BayName
=}

reactor Controller extends FrostBase{
    state pallet_destinations = {={}=}
    state pallets_at_destination = {={}=}
    state actions = {={}=}
    state pallet_names = []
    state belt_status 

    state n_bay_status = {=[True, True, True]=}
    state o_bay_status = {=[True, True, True]=}
    state p_bay_status = {=[True, True, True]=}
    state z_bay_status = True
    state lu_bay_status = True

    output to_switches
    output to_bayes
    output to_segments

    input from_frost
    output to_frost
    output pallet_realeased 

    logical action control_af
    logical action control_bh
    logical action control_ci
    logical action control_dl
    logical action control_em
    logical action control_lu
    logical action create_pallet

    state pallets_to_be_created = []

    logical action create_pallet_event
    state messages = []
    logical action message_to_send
    // @label create_pallet
    reaction (create_pallet_event) -> to_switches, to_bayes, to_segments{=
        dest, pallet_id = self.pallets_to_be_created.pop(0)
        
        self.pallet_names.append(pallet_id)
        self.pallet_destinations[pallet_id] = "0"
        self.actions[pallet_id] = None

        message = [[dest.value], [ControllerCommand.create, None], [pallet_id]]
        self.logger.debug(f"Message created: {message}")
        if isinstance(dest, SwitchName):
            self._set_output_port(message, to_switches)

        elif isinstance(dest, SegmentName):            
            self._set_output_port(message, to_segments)

        elif isinstance(dest, BayName):
            self._set_output_port(message, to_bayes)

        
        if self.pallets_to_be_created:
            create_pallet_event.schedule(0)
    =}

    method new_pallet_created(pallet_id){=
        self.pallet_destinations[pallet_id] = "0"
        self.actions[pallet_id] = SwitchAction.advance
        self.pallet_names.append(pallet_id)
    =}

    state bh_status = {={InterchangeInputs.BAY: None, InterchangeInputs.UPPER_SEGMENT: None, InterchangeInputs.LOWER_SEGMENT: None}=}
    state ci_status = {={InterchangeInputs.BAY: None, InterchangeInputs.UPPER_SEGMENT: None, InterchangeInputs.LOWER_SEGMENT: None}=}
    state dl_status = {={InterchangeInputs.BAY: None, InterchangeInputs.UPPER_SEGMENT: None, InterchangeInputs.LOWER_SEGMENT: None}=}
    state em_status = {={InterchangeInputs.BAY: None, InterchangeInputs.UPPER_SEGMENT: None, InterchangeInputs.LOWER_SEGMENT: None}=}
    state af_status = {={InterchangeInputs.BAY: None, InterchangeInputs.UPPER_SEGMENT: None, InterchangeInputs.LOWER_SEGMENT: None}=}
    state bh_stop = False
    state ci_stop = False
    state dl_stop = False
    state em_stop = False
    state af_stop = False
    
    ############################## Start and End REACTIONS ##############################
    reaction(shutdown){=
        self.logger.warning(f"Conveyor state: {self.belt_status}, \n {self.bh_status}, \n {self.ci_status}, \n {self.dl_status}, \n {self.em_status}, \n {self.af_status}")
    =}
    reaction (startup)-> to_switches, to_bayes, create_pallet, create_pallet_event{=
        self.belt_status = {SwitchName.A.value: True, SwitchName.B.value: True, SwitchName.C.value: True, SwitchName.D.value: True, SwitchName.E.value: True, SwitchName.F.value: True, BayName.LU.value: True, SwitchName.H.value: True, SwitchName.I.value: True, SwitchName.L.value: True, SwitchName.M.value: True}
        self.pallets_to_be_created.append([SegmentName.Segment_1, 1])
        self.pallets_to_be_created.append([SegmentName.Segment_2, 2])
        self.pallets_to_be_created.append([SegmentName.Segment_3, 3])
        self.pallets_to_be_created.append([SegmentName.Segment_1, 4])
        self.pallets_to_be_created.append([SegmentName.Segment_8, 5])
        self.pallets_to_be_created.append([SegmentName.Segment_2, 6])
        self.pallets_to_be_created.append([SegmentName.Segment_6, 7])
        self.pallets_to_be_created.append([SegmentName.Segment_7, 8])
        self.pallets_to_be_created.append([SegmentName.Segment_8, 9])
        self.pallets_to_be_created.append([SegmentName.Segment_1, 10])
        create_pallet_event.schedule(0)
    =}
    reaction(message_to_send) -> to_switches, to_bayes, to_segments, message_to_send{=
        if self.messages == []:
            return 0
        message = self.messages.pop(0)
        if isinstance(message[1][1], SegmentAction):
            self.logger.debug(f"Controller sending message to segments: {message}")
            self._set_output_port(message, to_segments)
        elif isinstance(message[1][1], SwitchAction):            
            if message[0] in BayName.values():
                self.logger.debug(f"Controller sending message to bay: {message}")
                self._set_output_port(message, to_bayes)
            else:
                self.logger.debug(f"Controller sending message to switches: {message}")
                self._set_output_port(message, to_switches)
        else:
            raise Exception(f"Controller error: no action to be performed {message}")

        if self.messages:
            self.logger.debug(f"Messages still in queue: {self.messages}, {self.dl_status}, {self.belt_status["L"]}")
            message_to_send.schedule(int(len(self.messages) + 1))
    =}

    ############################### CONTROL REACTIONS ##############################
    method _check_interchange_status(switches){=
        '''
        check if all the switches involved in the interchange are free
            switches: list of switches involved in the interchange
            return: True if all the switches are free, False otherwise
        '''
        return all(self.belt_status[switch] == True for switch in switches)
    =}
    method lock_positions(pos, act, switches, stop){=
        '''
        update the status of the switches involved in the action
            pos: position of the pallet in the interchange (InterchangeInputs)
            act: action to be performed by the pallet (SwitchAction)
            switches: list of switches involved in the interchange       
        '''

        if act == SwitchAction.advance:
            if pos == InterchangeInputs.UPPER_SEGMENT:
                self.belt_status[switches[0]] = False
            elif pos == InterchangeInputs.LOWER_SEGMENT:
                self.belt_status[switches[1]] = False
            elif pos == InterchangeInputs.BAY:
                self.belt_status[switches[0]] = False
        elif act == SwitchAction.go_to_bay:
            if pos == InterchangeInputs.UPPER_SEGMENT:
                self.belt_status[switches[0]] = False
        else:
            stop = True
            for switch in switches:
                self.belt_status[switch] = False
    =}
    method take_decision_over_interchange(switch_list, stop, status, bay, upper_segment, lower_segment){=
        for switch in switch_list:
            if switch not in SwitchName.values():
                raise Exception(f"Controller error: invalid switch name {switch}")
        #Update lock on the interchange
        if self._check_interchange_status(switch_list):
            stop = False

        #Get the position of the pallet to be moved
        interchange_pos = schedule_with_priority(status, self.actions)
        if interchange_pos == None:
            return None
        pos = interchange_pos[0]
        pallet_id = status[pos]
        action = self.actions[pallet_id]

        #Check if the action can be performed
        if stop == True:
            return None
        
        elif action == SwitchAction.cross:
            if not self._check_interchange_status(switch_list):
                return None
        elif action == SwitchAction.advance:
            if pos == InterchangeInputs.UPPER_SEGMENT or pos == InterchangeInputs.BAY:
                if self.belt_status[switch_list[0]] == False:
                    return None
            elif pos == InterchangeInputs.LOWER_SEGMENT:
                if self.belt_status[switch_list[1]] == False:
                    return None
        elif action == SwitchAction.go_to_bay:
            if pos == InterchangeInputs.UPPER_SEGMENT:
                if self.belt_status[switch_list[0]] == False:
                    return None
            else: # From lower segment or bay, needs both free
                if not self._check_interchange_status(switch_list):
                    return None

        #Prepare the header of the message
        message = [[], [], []]
        targets = []
        for pos in interchange_pos:
            if pos == InterchangeInputs.BAY:
                targets.append(bay)
                status[pos] = None
                break
            elif pos == InterchangeInputs.LOWER_SEGMENT:
                targets.append(lower_segment)
                status[pos] = None
            elif pos == InterchangeInputs.UPPER_SEGMENT:
                targets.append(upper_segment)
                status[pos] = None

        message[0] = targets
        #If both segments are involved and no stop, advance both
        if len(interchange_pos) == 2 and stop == False:
            message[1] = [ControllerCommand.move, SegmentAction.advance]
            for target in switch_list:                    
                self.belt_status[target] = False
            
            return message
        
        #If only one segment is involved, perform the action
        self.lock_positions(pos, action, switch_list, self.em_stop)
        if pos == InterchangeInputs.UPPER_SEGMENT or pos == InterchangeInputs.LOWER_SEGMENT:
            message[1] = [ControllerCommand.move, SegmentAction.advance]
        elif pos == InterchangeInputs.BAY:
            message[1] = [ControllerCommand.move, action]      

        if message[1] == []:
            raise Exception(f"Controller error: no action to be performed")
        return message
    =}
    // @label control_af
    reaction(control_af) -> message_to_send{=
        switch_list = [SwitchName.F.value, SwitchName.A.value]
        message = self.take_decision_over_interchange(switch_list, self.af_stop, self.af_status, None, SegmentName.Segment_4_2.value, None)
        if message == None:
            self.logger.debug("No message generated in control_af")
            return 0
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    // @label control_bh
    reaction(control_bh)-> message_to_send{=
        switch_list = [SwitchName.H.value, SwitchName.B.value]
        message = self.take_decision_over_interchange(switch_list, self.bh_stop, self.bh_status, BayName.Bay4_1, SegmentName.Segment_3.value, SegmentName.Segment_5.value)
        if message == None:
            self.logger.debug("No message generated in control_bh")
            return 0

        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    // @label control_ci
    reaction(control_ci)-> message_to_send{=
        switch_list = [SwitchName.I.value, SwitchName.C.value]
        message = self.take_decision_over_interchange(switch_list, self.ci_stop, self.ci_status, BayName.Bay3_1.value, SegmentName.Segment_2.value, SegmentName.Segment_6.value)
        if message == None:
            self.logger.debug("No message generated in control_ci")
            return 0

        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    // @label control_dl
    reaction(control_dl)-> message_to_send{=
        switch_list = [SwitchName.L.value, SwitchName.D.value]
        message = self.take_decision_over_interchange(switch_list, self.dl_stop, self.dl_status, BayName.Bay2_1.value, SegmentName.Segment_1.value, SegmentName.Segment_7.value)
        if message == None:
            self.logger.debug("No message generated in control_dl")
            return 0

        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    // @label control_em
    reaction(control_em)-> message_to_send{=
        switch_list = [SwitchName.M.value, SwitchName.E.value]
        message = self.take_decision_over_interchange(switch_list, self.em_stop, self.em_status, BayName.Bay1_1.value, None, SegmentName.Segment_8.value)
        if message == None:
            self.logger.debug("No message generated in control_em")
            return 0

        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))   
    =}
    // @label control_lu
    reaction(control_lu) -> message_to_send{=
        switch_list = BayName.LU.value
        message = None
        if self.belt_status[BayName.LU.value] == False:
            return 0
        else:
            message = [[], [], []]
            message[0] = [SegmentName.Segment_4_1.value]
            message[1] = [ControllerCommand.move, SegmentAction.advance]
        if message == None:
            raise Exception(f"Controller error: no action to be performed")
        self.belt_status[BayName.LU.value] = False
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    
    ############################## SEGMENT REACTIONS ##################################
    method handle_segment_event(value, switch_name, status, position){=
        if not isinstance(value, (list, tuple)) or len(value) != 2:
            raise Exception(f"Controller error: invalid request format {value}")

        self.logger.debug(f"Controller received segment event {value}")
        event = value[0]
        pallet_id = value[1]
        if not isinstance(event, Events):
            raise Exception(f"Controller error: invalid event {event}")
        if pallet_id != None and pallet_id not in self.pallet_names:
            self.new_pallet_created(pallet_id)

        if event == Events.pallet_released:
            status[position] = pallet_id
            if pallet_id == None:                
                return 0

            self.actions[pallet_id] = calculate_next_action(switch_name.value, self.pallet_destinations[pallet_id])
                    
        elif event == Events.pallet_arrived:
            if pallet_id == None:
                raise Exception(f"Controller error: invalid pallet id {pallet_id} for event {event}")

            status[position] = pallet_id
            self.actions[pallet_id] = calculate_next_action(switch_name.value, self.pallet_destinations[pallet_id])        
    =}
    input ab_request
    // @label segment_ab
    reaction(ab_request) -> control_bh{=
        value = ab_request.value
        self.handle_segment_event(value, SwitchName.B, self.bh_status, InterchangeInputs.LOWER_SEGMENT)
        control_bh.schedule(0)        
    =}
    input bc_request
    // @label segment_bc
    reaction(bc_request) -> control_ci{=
        value = bc_request.value
        self.handle_segment_event(value, SwitchName.C, self.ci_status, InterchangeInputs.LOWER_SEGMENT)
        control_ci.schedule(0)
    =}
    input cd_request
    // @label segment_cd
    reaction(cd_request) -> control_dl{=
        value = cd_request.value
        self.handle_segment_event(value, SwitchName.D, self.dl_status, InterchangeInputs.LOWER_SEGMENT)
        control_dl.schedule(0)
    =}
    input de_request
    // @label segment_de
    reaction(de_request) -> control_em{=
        value = de_request.value
        self.handle_segment_event(value, SwitchName.E, self.em_status, InterchangeInputs.LOWER_SEGMENT)
        control_em.schedule(0)
    =}
    input ml_request
    // @label segment_ml
    reaction(ml_request) -> control_dl{=
        value = ml_request.value
        self.handle_segment_event(value, SwitchName.L, self.dl_status, InterchangeInputs.UPPER_SEGMENT)
        control_dl.schedule(0)
    =}
    input li_request
    // @label segment_li
    reaction(li_request) -> control_ci{=
        value = li_request.value
        self.handle_segment_event(value, SwitchName.I, self.ci_status, InterchangeInputs.UPPER_SEGMENT)
        control_ci.schedule(0)
    =}
    input ih_request
    // @label segment_ih
    reaction(ih_request) -> control_bh{=
        value = ih_request.value
        self.handle_segment_event(value, SwitchName.H, self.bh_status, InterchangeInputs.UPPER_SEGMENT)
        control_bh.schedule(0)
    =}
    input hg_request
    // @label segment_hg
    reaction(hg_request) -> control_lu{=
        value = hg_request.value
        control_lu.schedule(0)
    =}
    input gf_request
    // @label segment_gf
    reaction(gf_request) -> control_af{=
        value = gf_request.value
        self.handle_segment_event(value, SwitchName.F, self.af_status, InterchangeInputs.UPPER_SEGMENT)
        control_af.schedule(0)
    =}

    ############################## BAY REACTIONS ##############################
    input bay1_request
    // @label message_from_bay_1
    reaction(bay1_request) -> to_bayes, to_segments, control_em{=
        return 0
    =}
    input bay2_request
    // @label message_from_bay_2
    reaction(bay2_request) -> to_bayes, control_dl{=
        return 0
    =}
    input bay3_request
    // @label message_from_bay_3
    reaction(bay3_request) -> to_bayes, control_ci{=
        return 0
    =}
    input bay4_request
    // @label message_from_bay_4
    reaction(bay4_request) -> to_bayes, control_bh{=
        return 0
    =}
    input bay5_request
    // @label message_from_bay_5
    reaction(bay5_request){=
        
    =}

    ############################## SWITCH REACTIONS ##############################
    method _prepare_message_for_switch(value, switch, control){=
        event = value[0]
        if event not in Events:
            raise Exception(f"Controller error: invalid event {event} from switch {switch}")
        pallet_id = value[1]
        message = None
        self.logger.debug(f"Controller handling switch {switch} event {value}, current belt status: {control}")
        if event == Events.pallet_arrived:
            if pallet_id not in self.pallet_names:
                self.new_pallet_created(pallet_id)

            self.logger.debug(f"Controller received switch event {value} from switch {switch}")
            self.belt_status[switch] = False
            self.actions[pallet_id] = calculate_next_action(switch, self.pallet_destinations[pallet_id])
            message = [[switch], [ControllerCommand.move, self.actions[pallet_id]], [None]]

        elif event == Events.pallet_released:
            self.logger.debug(f"Controller received switch event {value} from switch {switch}")
            self.belt_status[switch] = True
            control.schedule(0)

        return message
    =}
    input switch_a_request
    // @label switch_a
    reaction (switch_a_request)-> message_to_send, control_af{=
        value = switch_a_request.value
        message = self._prepare_message_for_switch(value, SwitchName.A.value, control_af)
        if message == None:
            return 0
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    input switch_b_request
    // @label switch_b
    reaction (switch_b_request) -> message_to_send, control_bh{=
        value = switch_b_request.value
        message = self._prepare_message_for_switch(value, SwitchName.B.value, control_bh)
        if message == None:
            return 0
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    input switch_c_request
    // @label switch_c
    reaction (switch_c_request) -> message_to_send, control_ci{=
        value = switch_c_request.value
        message = self._prepare_message_for_switch(value, SwitchName.C.value, control_ci)
        if message == None:
            return 0
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    input switch_d_request
    // @label switch_d
    reaction (switch_d_request) -> message_to_send, control_dl{=
        value = switch_d_request.value
        message = self._prepare_message_for_switch(value, SwitchName.D.value, control_dl)
        if message == None:
            return 0
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    input switch_e_request
    // @label switch_e
    reaction (switch_e_request) -> message_to_send, control_em{=
        value = switch_e_request.value
        message = self._prepare_message_for_switch(value, SwitchName.E.value, control_em)
        if message == None:
            return 0
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    input switch_f_request
    // @label switch_f
    reaction (switch_f_request) -> message_to_send, control_af{=
        value = switch_f_request.value
        message = self._prepare_message_for_switch(value, SwitchName.F.value, control_af)
        if message == None:
            return 0
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    input switch_h_request
    // @label switch_h
    reaction (switch_h_request) -> message_to_send, control_bh{=
        value = switch_h_request.value
        message = self._prepare_message_for_switch(value, SwitchName.H.value, control_bh)
        if message == None:
            return 0
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    input switch_i_request
    // @label switch_i
    reaction (switch_i_request) -> message_to_send, control_ci{=
        value = switch_i_request.value
        message = self._prepare_message_for_switch(value, SwitchName.I.value, control_ci)
        if message == None:
            return 0
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    input switch_l_request
    // @label switch_l
    reaction (switch_l_request) -> message_to_send, control_dl{=
        value = switch_l_request.value
        message = self._prepare_message_for_switch(value, SwitchName.L.value, control_dl)
        if message == None:
            return 0
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    input switch_m_request
    // @label switch_m
    reaction (switch_m_request) -> message_to_send, control_em{=
        value = switch_m_request.value
        message = self._prepare_message_for_switch(value, SwitchName.M.value, control_em)
        if message == None:
            return 0
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    
    ############################## FROST ##############################
    // @label from_frost
    reaction(from_frost)-> message_to_send{=
        palletNum = from_frost.value[0]
        destination = from_frost.value[1]
        self.logger.error(f"Complete reaction")
        ##TODO        
    =}

}