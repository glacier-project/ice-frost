target Python{
    files: [
        source_folder/controller_utils.py,
        source_folder/pallet.py, 
        source_folder/routing_algorithm.py, 
        source_folder/bay_routing_algorithm.py,
        source_folder/utils.py
    ]
};

import FrostBase from "../../../frost/src/lib/FrostBase.lf"

preamble{=
    from pallet import Pallet
    from controller_utils import new_destination, schedule_with_priority
    from bay_routing_algorithm import compute_bay_route, check_bay_available, leave_bay, update_bay_positions
    from routing_algorithm import Routing
    from utils import Events, ControllerCommand, SwitchAction, SwitchName, InterchangeName, SegmentName, Mutex, InterchangeInputs, BayName
=}

reactor Controller extends FrostBase{
    state pallet_destinations = {={}=}
    state pallets_at_destination = {={}=}
    state actions = {={}=}
    state pallet_names = []
    state belt_status 

    state n_bay_status = {=[True, True, True]=}
    state o_bay_status = {=[True, True, True]=}
    state p_bay_status = {=[True, True, True]=}
    state z_bay_status = True
    state lu_bay_status = True

    output to_switches
    output to_bayes
    output to_segments

    input from_frost
    output to_frost
    output pallet_realeased 

    logical action control_af
    logical action control_bh
    logical action control_ci
    logical action control_dl
    logical action control_em
    logical action control_lu
    logical action create_pallet

    state pallets_to_be_created = []

    logical action create_pallet_event
    // @label create_pallet
    reaction (create_pallet_event) -> to_switches, to_bayes, to_segments{=
        dest, pallet = self.pallets_to_be_created.pop(0)        
        self.pallet_names.append(pallet)
        self.pallet_destinations.update({pallet.id: None})
        self.actions.update({pallet.id: None})

        message = [[dest.value], [ControllerCommand.create, None], [pallet]]

        if isinstance(dest, SwitchName):
            self._set_output_port(message, to_switches)

        elif isinstance(dest, SegmentName):            
            self._set_output_port(message, to_segments)

        elif isinstance(dest, BayName):
            self._set_output_port(message, to_bayes)
        
        if self.pallets_to_be_created:
            create_pallet_event.schedule(1)
    =}

    method new_pallet_created(pallet_id){=
        self.pallet_destinations[pallet_id] = None
        self.actions[pallet_id] = SwitchAction.advance
        self.pallet_names.append(pallet_id)
    =}

    state bh_status = {={InterchangeInputs.BAY: None, InterchangeInputs.UPPER_SEGMENT: [], InterchangeInputs.LOWER_SEGMENT: []}=}
    state ci_status = {={InterchangeInputs.BAY: None, InterchangeInputs.UPPER_SEGMENT: [], InterchangeInputs.LOWER_SEGMENT: []}=}
    state dl_status = {={InterchangeInputs.BAY: None, InterchangeInputs.UPPER_SEGMENT: [], InterchangeInputs.LOWER_SEGMENT: []}=}
    state gf_status = []
    state hg_status = []
    state de_status = []
    state p_buffers = []
    state o_buffers = []
    state n_buffers = []
    state m_buffers = []
    
    ############################## ACTION REACTIONS ##############################
    reaction(shutdown){=
        self.logger.debug(f"Conveyor state: {self.conveyor}")
    =}

    reaction (startup)-> to_switches, to_bayes, create_pallet{=
        self.belt_status = {SwitchName.A.value: True, SwitchName.B.value: True, SwitchName.C.value: True, SwitchName.D.value: True, SwitchName.E.value: True, SwitchName.F.value: True, SwitchName.G.value: True, SwitchName.H.value: True, SwitchName.I.value: True, SwitchName.L.value: True, SwitchName.M.value: True}
        self.pallets_to_be_created[0] = [SwitchName.I, 1]
        self.pallets_to_be_created[1] = [SwitchName.C, 2]
        self.pallets_to_be_created[2] = [SwitchName.L, 3]
        self.pallets_to_be_created[3] = [SwitchName.C, 4]
        self.pallets_to_be_created[4] = [SwitchName.D, 5]
        self.pallets_to_be_created[5] = [SwitchName.E, 6]
        self.pallets_to_be_created[6] = [SwitchName.H, 7]
        self.pallets_to_be_created[7] = [SwitchName.A, 8]
        self.pallets_to_be_created[8] = [SwitchName.B, 9]
        self.pallets_to_be_created[9] = [SwitchName.I, 10]
        for z in range(1, len(self.pallets)):
            create_pallet_event.schedule(z-1)
    =}
    
    ############################### CONTROL REACTIONS ##############################
    // @label control_af
    reaction(control_af) -> to_segments{=
        if self.conveyor["A"] == True and self.conveyor["F"] == True and not(not self.GF_buffers):
            self.conveyor["A"] = False
            self.conveyor["F"] = False
            self.GF_buffers.pop(0)
            y = ["GF"]
            to_segments.set(y)        
    =}
    // @label control_bh
    reaction(control_bh)-> to_segments, to_bayes, pallet_realeased {=
        if self.conveyor["B"] == True or self.conveyor["H"] == True:
            y = schedule_with_priority(self.BH_buffers)
            if y != None:
                temp = None
                if y != ControllerCommand.double_advance:
                    if y == SwitchAction.go_to_bay:
                        temp = self.BH_buffers[y]
                    else:
                        temp = self.BH_buffers[y][0]
                if temp != None and temp.action == SwitchAction.advance:
                    if y == ControllerCommand.up_advance and self.conveyor["H"] == True:
                        self.BH_buffers[ControllerCommand.up_advance].pop(0)
                        self.conveyor["H"] = False  
                        y = ["IH"]
                        to_segments.set(y)
                    elif y == ControllerCommand.up_advance and self.conveyor["B"] == True:
                        self.BH_buffers[ControllerCommand.up_advance].pop(0)
                        self.conveyor["B"] = False
                        y = ["AB"]
                        to_segments.set(y)
                elif self.conveyor["B"] == True and self.conveyor["H"] == True:
                    if y == SwitchAction.go_to_bay:
                        pallet_realeased .set(self.BH_buffers[SwitchAction.go_to_bay].id)
                        self.BH_buffers[SwitchAction.go_to_bay] = None
                        to_bayes.set(["pallet_realeased ", "N"])  
                        
                        self.N_[0] = True          
                    elif y == ControllerCommand.up_advance:
                        self.BH_buffers[ControllerCommand.up_advance].pop(0)
                        y = ["IH"]
                        to_segments.set(y)
                    elif y == ControllerCommand.up_advance:
                        self.BH_buffers[ControllerCommand.up_advance].pop(0)
                        y = ["AB"]
                        to_segments.set(y)
                    elif y == ControllerCommand.double_advance:
                        self.BH_buffers[ControllerCommand.up_advance].pop(0)
                        self.BH_buffers[ControllerCommand.up_advance].pop(0)
                        y = [ControllerCommand.double_advance, "AB", "IH"]
                        to_segments.set(y)
                    
                    self.conveyor["B"] = False
                    self.conveyor["H"] = False  
            else:
                self.conveyor["B"] = True
                self.conveyor["H"] = True                          
    =}
    // @label control_ci
    reaction(control_ci)-> to_segments, to_bayes, pallet_realeased {=
        if self.conveyor["C"] == True or self.conveyor["I"] == True:
            y = schedule_with_priority(self.CI_buffers)
            if y != None:
                temp = None
                if y != ControllerCommand.double_advance:
                    if y == SwitchAction.go_to_bay:
                        temp = self.CI_buffers[y]   
                    else:
                        temp = self.CI_buffers[y][0]
                if temp != None and temp.action == SwitchAction.advance:
                    if y == ControllerCommand.up_advance and self.conveyor["I"] == True:
                        self.CI_buffers[ControllerCommand.up_advance].pop(0)
                        self.conveyor["I"] = False
                        y = ["LI"]
                        to_segments.set(y)
                    elif y == ControllerCommand.up_advance and self.conveyor["C"] == True:
                        self.CI_buffers[ControllerCommand.up_advance].pop(0)
                        self.conveyor["C"] = False
                        y = ["BC"]
                        to_segments.set(y)
                elif self.conveyor["C"] == True and self.conveyor["I"] == True:
                    if y == SwitchAction.go_to_bay:
                        pallet_realeased .set(self.CI_buffers[SwitchAction.go_to_bay].id)
                        self.CI_buffers[SwitchAction.go_to_bay] = None
                        to_bayes.set(["pallet_realeased ", "O"]) 
                        self.O_[0] = True
                    elif y == ControllerCommand.up_advance:
                        self.CI_buffers[ControllerCommand.up_advance].pop(0)
                        y = ["LI"]
                        to_segments.set(y)
                    elif y == ControllerCommand.up_advance:
                        self.CI_buffers[ControllerCommand.up_advance].pop(0)
                        y = ["BC"]
                        to_segments.set(y)
                    elif y == ControllerCommand.double_advance:
                        self.CI_buffers[ControllerCommand.up_advance].pop(0)
                        self.CI_buffers[ControllerCommand.up_advance].pop(0)
                        y = [ControllerCommand.double_advance, "BC", "LI"]
                        to_segments.set(y)
                    
                    self.conveyor["C"] = False
                    self.conveyor["I"] = False  
            else:
                self.conveyor["C"] = True
                self.conveyor["I"] = True                          
    =}
    // @label control_dl
    reaction(control_dl)-> to_segments, to_bayes, pallet_realeased {=
        if self.conveyor["D"] == True or self.conveyor["L"] == True:
            y = schedule_with_priority(self.DL_buffers)
            if y != None:
                temp = None
                if y != ControllerCommand.double_advance:
                    if y == SwitchAction.go_to_bay:
                        temp = self.DL_buffers[y]
                    else:
                        temp = self.DL_buffers[y][0]
                    
                if temp != None and temp.action == SwitchAction.advance:
                    if y == ControllerCommand.up_advance and self.conveyor["L"] == True:
                        self.DL_buffers[ControllerCommand.up_advance].pop(0)
                        self.conveyor["L"] = False
                        y = ["ML"]
                        to_segments.set(y)
                    elif y == ControllerCommand.up_advance and self.conveyor["D"] == True:
                        self.DL_buffers[ControllerCommand.up_advance].pop(0)
                        self.conveyor["D"] = False
                        y = ["CD"]
                        to_segments.set(y)
                elif self.conveyor["D"] == True and self.conveyor["L"] == True:
                    if y == SwitchAction.go_to_bay:
                        pallet_realeased .set(self.DL_buffers[SwitchAction.go_to_bay].id)
                        self.DL_buffers[SwitchAction.go_to_bay] = None
                        to_bayes.set(["pallet_realeased ", "P"])   
                        self.P_[0] = True
                    elif y == ControllerCommand.up_advance:
                        self.DL_buffers[ControllerCommand.up_advance].pop(0)
                        y = ["ML"]
                        to_segments.set(y)
                    elif y == ControllerCommand.up_advance:
                        self.DL_buffers[ControllerCommand.up_advance].pop(0)
                        y = ["CD"]
                        to_segments.set(y)
                    elif y == ControllerCommand.double_advance:
                        self.DL_buffers[ControllerCommand.up_advance].pop(0)
                        self.DL_buffers[ControllerCommand.up_advance].pop(0)
                        y = [ControllerCommand.double_advance, "CD", "ML"]
                        to_segments.set(y)
                    
                    self.conveyor["D"] = False
                    self.conveyor["L"] = False  
            else:
                self.conveyor["D"] = True
                self.conveyor["L"] = True                          
    =}
    // @label control_em
    reaction(control_em)-> to_segments, to_bayes{=
        if self.conveyor["E"] == True and self.conveyor["M"] == True and (self.DE_buffers or self.M_buffers):
            self.conveyor["E"] = False
            self.conveyor["M"] = False
            if self.M_buffers:
                y = [ControllerCommand.move, SwitchAction.advance]
                BAY_Z_to_switches.set(y)
                self.M_buffers.pop(0)
                self.Z = True
            else:             
                self.DE_buffers.pop(0)
                y = ["DE"]
                to_segments.set(y)
    =}
    // @label control_lu
    reaction(control_lu) -> to_segments{=
        if self.conveyor["G"] == True and (self.hg_status):
            self.conveyor["G"] = False
            self.hg_status.pop(0)
            y = ["HG"]
            to_segments.set(y)
    =}
    
    ############################## SEGMENT REACTIONS ##################################
    method handle_segment_event(value, switch_name, status, position){=
        if not isinstance(value, (list, tuple)) or len(value) != 2:
            raise Exception(f"Controller error: invalid request format {value}")

        event = value[0]
        pallet_id = value[1]
        if not isinstance(event, Events):
            raise Exception(f"Controller error: invalid event {event}")
        if pallet_id != None and pallet_id not in self.pallet_names:
            self.new_pallet_created(pallet_id)

        if event == Events.pallet_released:
            if pallet_id == None:
                self.status[position] = None
                return 0

            self.status[position] = pallet_id
            self.actions[pallet_id] = calculate_next_action(switch_name, self.pallet_destinations[pallet_id])
                    
        elif event == Events.pallet_arrived:
            if pallet_id == None:
                raise Exception(f"Controller error: invalid pallet id {pallet_id} for event {event}")

            self.status[position] = pallet_id
            self.actions[pallet_id] = calculate_next_action(switch_name, self.pallet_destinations[pallet_id])        
    =}

    input ab_request
    // @label segment_ab
    reaction(ab_request) -> control_bh{=
        value = self._get_input_values(ab_request)
        self.handle_segment_event(value, SwitchName.B, self.bh_status, InterchangeInputs.LOWER_SEGMENT)
        control_bh.schedule(1)        
    =}
    input bc_request
    // @label segment_bc
    reaction(bc_request) -> control_ci{=
        value = self._get_input_values(bc_request)
        self.handle_segment_event(value, SwitchName.C, self.ci_status, InterchangeInputs.LOWER_SEGMENT)
        control_ci.schedule(1)
    =}
    input cd_request
    // @label segment_cd
    reaction(cd_request) -> control_dl{=
        value = self._get_input_values(cd_request)
        self.handle_segment_event(value, SwitchName.D, self.dl_status, InterchangeInputs.LOWER_SEGMENT)
        control_dl.schedule(1)
    =}
    input de_request
    // @label segment_de
    reaction(de_request) -> control_em{=
        value = self._get_input_values(de_request)
        self.handle_segment_event(value, SwitchName.E, self.de_status, InterchangeInputs.LOWER_SEGMENT)
        control_em.schedule(1)
    =}
    input ml_request
    // @label segment_ml
    reaction(ml_request) -> control_dl{=
        value = self._get_input_values(ml_request)
        self.handle_segment_event(value, SwitchName.L, self.dl_status, InterchangeInputs.UPPER_SEGMENT)
        control_dl.schedule(1)
    =}
    input li_request
    // @label segment_li
    reaction(li_request) -> control_ci{=
        value = self._get_input_values(li_request)
        self.handle_segment_event(value, SwitchName.I, self.ci_status, InterchangeInputs.UPPER_SEGMENT)
        control_ci.schedule(1)
    =}
    input ih_request
    // @label segment_ih
    reaction(ih_request) -> control_bh{=
        value = self._get_input_values(ih_request)
        self.handle_segment_event(value, SwitchName.H, self.bh_status, InterchangeInputs.UPPER_SEGMENT)
        control_bh.schedule(1)
    =}
    input hg_request
    // @label segment_hg
    reaction(hg_request) -> control_lu{=
        value = self._get_input_values(hg_request)
        self.handle_segment_event(value, SwitchName.G, self.hg_status, None)
        control_lu.schedule(1)
    =}
    input gf_request
    // @label segment_gf
    reaction(gf_request) -> control_af{=
        value = self._get_input_values(gf_request)
        self.handle_segment_event(value, SwitchName.F, self.af_status, None)
        control_af.schedule(1)
    =}

    ############################## BAY REACTIONS ##############################
    input bay1_request
    // @label message_from_bay_1
    reaction(bay1_request) -> to_bayes, to_segments, control_em{=
        temp = BAY_Z_IN.value
        if temp[0] == ControllerCommand.move:
            to_segments.set(["DE", "STOP"])
            self.M_buffers.append(temp[2])
            BAY_Z_to_switches.set([ControllerCommand.move, SwitchAction.advance])
        elif temp[0] == Events.pallet_arrived:
            self.conveyor["E"] = True 
            self.conveyor["M"] = True
            to_segments.set(["DE"])
            self.Z = True
            
            control_EM.schedule(0)
    =}
    input bay2_request
    // @label message_from_bay_2
    reaction(bay2_request) -> to_bayes, control_dl{=
        if BAY_P_IN.value[0] == ControllerCommand.move:
            s = "P" + BAY_P_IN.value[1]
            ctrl = int(BAY_P_IN.value[3]) if (BAY_P_IN.value[2]) == None else int(BAY_P_IN.value[2][1])
            route =  compute_bay_route(s, BAY_P_IN.value[2], "P")
            n = int(BAY_P_IN.value[1])
            update_bay_positions(self.P_, n, route[0])
            y = ControllerCommand.move, s, route[0]
            to_bayes.set(y)

        elif BAY_P_IN.value[0] == "Move_in_bay":
            s = "P" + BAY_P_IN.value[1]
            ctrl = int(BAY_P_IN.value[1]) - 1
            if not check_bay_available(self.P_, ctrl):
                return None  
            route =  compute_bay_route(s, BAY_P_IN.value[2], "P")
            n = int(BAY_P_IN.value[1])
            update_bay_positions(self.P_, n, route[0])
            y = ControllerCommand.move, s, route[0]
            to_bayes.set(y)

        elif BAY_P_IN.value[0] == Events.pallet_arrived:
            n = int(BAY_P_IN.value[2]) - 1
            self.P_[n] = False            
            if n == 1:
                self.P_[2] = True
            elif n == 0:
                self.P_[2] = True
                self.P_[1] = True

        elif BAY_P_IN.value == "Free":
            self.conveyor["L"] = True
            self.conveyor["D"] = True

        elif BAY_P_IN.value[0] == "Pallet_incoming":
            self.DL_buffers[SwitchAction.go_to_bay] = BAY_P_IN.value[1]
            control_DL.schedule(0)
    =}
    input bay3_request
    // @label message_from_bay_3
    reaction(bay3_request) -> to_bayes, control_ci{=
        if BAY_O_IN.value[0] == "Move_in_bay":
            s = "O" + BAY_O_IN.value[1]
            ctrl = int(BAY_O_IN.value[1]) - 1
            if not check_bay_available(self.O_, ctrl):
                return None            
            route =  compute_bay_route(s, BAY_O_IN.value[2], "O")
            n = int(BAY_O_IN.value[1])
            update_bay_positions(self.O_, n, route[0])
            y = ControllerCommand.move, s, route[0]
            to_bayes.set(y)
    
        elif BAY_O_IN.value[0] == ControllerCommand.move:
            s = "O" + BAY_O_IN.value[1]
            route =  compute_bay_route(s, BAY_O_IN.value[2], "O")
            n = int(BAY_O_IN.value[1])
            update_bay_positions(self.O_, n, route[0])

            y = ControllerCommand.move, s, route[0]
            to_bayes.set(y)

        elif BAY_O_IN.value[0] == Events.pallet_arrived:
            n = int(BAY_O_IN.value[2]) - 1
            self.O_[n] = False            
            if n == 1:
                self.O_[2] = True
            elif n == 0:
                self.O_[2] = True
                self.O_[1] = True

        elif BAY_O_IN.value == "Free":
            self.conveyor["I"] = True
            self.conveyor["C"] = True
        
        elif BAY_O_IN.value[0] == "Pallet_incoming":
            self.CI_buffers[SwitchAction.go_to_bay] = BAY_O_IN.value[1]
            control_CI.schedule(0)        
    =}
    input bay4_request
    // @label message_from_bay_4
    reaction(bay4_request) -> to_bayes, control_bh{=
        if BAY_N_IN.value[0] == ControllerCommand.move:
            s = "N" + BAY_N_IN.value[1]
            route =  compute_bay_route(s, BAY_N_IN.value[2], "N")
            n = int(BAY_N_IN.value[1])
            update_bay_positions(self.N_, n, route[0])

            y = ControllerCommand.move, s, route[0]
            to_bayes.set(y)

        elif BAY_N_IN.value[0] == "Move_in_bay":
            s = "N" + BAY_N_IN.value[1]
            ctrl = int(BAY_N_IN.value[1]) - 1
            if not check_bay_available(self.N_, ctrl):
                return None
            route =  compute_bay_route(s, BAY_N_IN.value[2], "N")
            n = int(BAY_N_IN.value[1])
            update_bay_positions(self.N_, n, route[0])
            y = ControllerCommand.move, s, route[0]
            to_bayes.set(y)

        elif BAY_N_IN.value[0] == Events.pallet_arrived:
            n = int(BAY_N_IN.value[2]) - 1
            self.N_[n] = False            
            if n == 1:
                self.N_[2] = True
            elif n == 0:
                self.N_[2] = True
                self.N_[1] = True

        elif BAY_N_IN.value == "Free":
            self.conveyor["B"] = True
            self.conveyor["H"] = True

        elif BAY_N_IN.value[0] == "Pallet_incoming":
            self.BH_buffers[SwitchAction.go_to_bay] = BAY_N_IN.value[1]
            control_BH.schedule(0)

    =}
    input bay5_request
    // @label message_from_bay_5
    reaction(bay5_request){=
        if from_G.value[0] == Events.pallet_arrived:
            self.pallet_on_G = True           
    =}

    ############################## SWITCH REACTIONS ##############################
    method _prepare_message_for_switch(value, switch, control){=
        event = value[0]
        if not isinstance(event, Events):
            raise Exception(f"Controller error: invalid event {event}")
        pallet_id = value[1]
        message = None
        if event == Events.pallet_arrived.value:
            if pallet_id not in self.pallet_names:
                self.new_pallet_created(pallet_id)

            message = [[switch], [ControllerCommand.move, self.actions[pallet_id]], [None]]

        elif event == Events.pallet_released.value:
            self.belt_status[switch] = True
            control.schedule(0)

        return message
    =}
    input switch_a_request
    // @label switch_a
    reaction (switch_a_request)-> to_switches, control_af{=
        value = self._get_input_values(switch_a_request)
        message = self._prepare_message_for_switch(value, SwitchName.A.value, control_af)
        if message == None:
            return 0
        self._set_output_port(message, to_switches)
    =}
    input switch_b_request
    // @label switch_b
    reaction (switch_b_request) -> to_switches, control_bh{=
        value = self._get_input_values(switch_b_request)
        message = self._prepare_message_for_switch(value, SwitchName.B.value, control_bh)
        if message == None:
            return 0
        self._set_output_port(message, to_switches)
    =}
    input switch_c_request
    // @label switch_c
    reaction (switch_c_request) -> to_switches, control_ci{=
        value = self._get_input_values(switch_c_request)
        message = self._prepare_message_for_switch(value, SwitchName.C.value, control_ci)
        if message == None:
            return 0
        self._set_output_port(message, to_switches)
    =}
    input switch_d_request
    // @label switch_d
    reaction (switch_d_request) -> to_switches, control_dl{=
        value = self._get_input_values(switch_d_request)
        message = self._prepare_message_for_switch(value, SwitchName.D.value, control_dl)
        if message == None:
            return 0
        self._set_output_port(message, to_switches)
    =}
    input switch_e_request
    // @label switch_e
    reaction (switch_e_request) -> to_switches, control_em{=
        value = self._get_input_values(switch_e_request)
        message = self._prepare_message_for_switch(value, SwitchName.E.value, control_em)
        if message == None:
            return 0
        self._set_output_port(message, to_switches)
    =}
    input switch_f_request
    // @label switch_f
    reaction (switch_f_request) -> to_switches, control_af{=
        value = self._get_input_values(switch_f_request)
        message = self._prepare_message_for_switch(value, SwitchName.F.value, control_af)
        if message == None:
            return 0
        self._set_output_port(message, to_switches)
    =}
    input switch_h_request
    // @label switch_h
    reaction (switch_h_request) -> to_switches, control_bh{=
        value = self._get_input_values(switch_h_request)
        message = self._prepare_message_for_switch(value, SwitchName.H.value, control_bh)
        if message == None:
            return 0
        self._set_output_port(message, to_switches)
    =}
    input switch_i_request
    // @label switch_i
    reaction (switch_i_request) -> to_switches, control_ci{=
        value = self._get_input_values(switch_i_request)
        message = self._prepare_message_for_switch(value, SwitchName.I.value, control_ci)
        if message == None:
            return 0
        self._set_output_port(message, to_switches)
    =}
    input switch_l_request
    // @label switch_l
    reaction (switch_l_request) -> to_switches, control_dl{=
        value = self._get_input_values(switch_l_request)
        message = self._prepare_message_for_switch(value, SwitchName.L.value, control_dl)
        if message == None:
            return 0
        self._set_output_port(message, to_switches)
    =}
    input switch_m_request
    // @label switch_m
    reaction (switch_m_request) -> to_switches, control_em{=
        value = self._get_input_values(switch_m_request)
        message = self._prepare_message_for_switch(value, SwitchName.M.value, control_em)
        if message == None:
            return 0
        self._set_output_port(message, to_switches)
    =}
    
    ############################## FROST ##############################
    // @label from_frost
    reaction(from_frost)-> to_switches, to_segments, to_bayes{=
        palletNum = from_frost.value[0]
        destination = from_frost.value[1]
        self.logger.error(f"Complete reaction")
        ##TODO        
    =}

}