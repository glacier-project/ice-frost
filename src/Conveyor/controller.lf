target Python{
    files: [
        source_folder/pallet.py, 
        source_folder/routing_algorithm.py, 
        source_folder/bay_routing_algorithm.py,
        source_folder/interchange_scheduling.py,
        source_folder/utils.py
    ]
};

import FrostBase from "../../../frost/src/lib/FrostBase.lf"

preamble{=
    from pallet import Pallet
    from interchange_scheduling import schedule_with_priority
    from routing_algorithm import calculate_next_action
    from utils import Events, SegmentAction, ControllerCommand, SwitchAction, SwitchPort, BayAction, SwitchName, InterchangeName, SegmentName, InterchangeInputs, BayName
=}

reactor Controller extends FrostBase{
    state pallet_destinations = {={}=}
    state pallets_at_destination = {={}=}
    state actions = {={}=}
    state pallet_names = []
    state belt_status 

    state bay4_status = {=[0, 0, 0]=}
    state bay3_status = {=[0, 0, 0]=}
    state bay2_status = {=[0, 0, 0]=}
    state bay1_status = [0]
    state lu_bay_status = [0]

    output to_switches
    output to_bayes
    output to_segments

    input from_frost
    output to_frost
    output pallet_realeased 

    logical action control_af
    logical action control_bh
    logical action control_ci
    logical action control_dl
    logical action control_em
    logical action control_lu
    logical action create_pallet

    state pallets_to_be_created = []

    logical action create_pallet_event
    state messages = []
    logical action message_to_send
    // @label create_pallet
    reaction (create_pallet_event) -> to_switches, to_bayes, to_segments{=
        dest, pallet_id = self.pallets_to_be_created.pop(0)
        
        self.pallet_names.append(pallet_id)
        self.pallet_destinations[pallet_id] = "0"
        self.actions[pallet_id] = None

        message = [[dest.value], [ControllerCommand.create, None], [pallet_id]]
        self.logger.debug(f"Message created: {message}")
        if isinstance(dest, SwitchName):
            self._set_output_port(message, to_switches)

        elif isinstance(dest, SegmentName):            
            self._set_output_port(message, to_segments)

        elif isinstance(dest, BayName):
            self._set_output_port(message, to_bayes)
        
        if self.pallets_to_be_created:
            create_pallet_event.schedule(0)
    =}

    method new_pallet_created(pallet_id){=
        self.pallet_destinations[pallet_id] = "0"
        self.actions[pallet_id] = SwitchAction.advance
        self.pallet_names.append(pallet_id)
    =}

    state bh_status = {={InterchangeInputs.BAY: None, InterchangeInputs.UPPER_SEGMENT: None, InterchangeInputs.LOWER_SEGMENT: None}=}
    state ci_status = {={InterchangeInputs.BAY: None, InterchangeInputs.UPPER_SEGMENT: None, InterchangeInputs.LOWER_SEGMENT: None}=}
    state dl_status = {={InterchangeInputs.BAY: None, InterchangeInputs.UPPER_SEGMENT: None, InterchangeInputs.LOWER_SEGMENT: None}=}
    state em_status = {={InterchangeInputs.BAY: None, InterchangeInputs.UPPER_SEGMENT: None, InterchangeInputs.LOWER_SEGMENT: None}=}
    state lu_status = {={InterchangeInputs.BAY: None, InterchangeInputs.UPPER_SEGMENT: None, InterchangeInputs.LOWER_SEGMENT: None}=}
    state bh_stop = [False]
    state ci_stop = [False]
    state dl_stop = [False]
    state em_stop = [False]
    state af_stop = [False]

    ############################## Start and End REACTIONS ##############################
    reaction(shutdown){=
        self.logger.warning(f"Conveyor state: {self.belt_status}, \n HB: {self.bh_status}, \n IC: {self.ci_status}, \n DL: {self.dl_status}, \n EM: {self.em_status}, \n LU: {self.lu_status}")
    =}
    reaction (startup)-> to_switches, to_bayes, create_pallet, create_pallet_event{=
        self.belt_status = {SwitchName.A.value: True, SwitchName.B.value: True, SwitchName.C.value: True, SwitchName.D.value: True, SwitchName.E.value: True, SwitchName.F.value: True, BayName.LU.value: True, SwitchName.H.value: True, SwitchName.I.value: True, SwitchName.L.value: True, SwitchName.M.value: True}
        self.pallets_to_be_created.append([SegmentName.Segment_1, 1])
        self.pallets_to_be_created.append([SegmentName.Segment_2, 2])
        self.pallets_to_be_created.append([SegmentName.Segment_3, 3])
        self.pallets_to_be_created.append([SegmentName.Segment_1, 4])
        self.pallets_to_be_created.append([SegmentName.Segment_8, 5])
        self.pallets_to_be_created.append([SegmentName.Segment_2, 6])
        self.pallets_to_be_created.append([SegmentName.Segment_6, 7])
        self.pallets_to_be_created.append([SegmentName.Segment_7, 8])
        self.pallets_to_be_created.append([SegmentName.Segment_8, 9])
        self.pallets_to_be_created.append([SegmentName.Segment_1, 10])
        create_pallet_event.schedule(0)
    =}
    reaction(message_to_send) -> to_switches, to_bayes, to_segments, message_to_send{=
        if self.messages == []:
            return 0
        message = self.messages.pop(0)
        self.logger.debug(f"Controller sending message: {message}")
        if isinstance(message[1][1], SegmentAction):
            self.logger.debug(f"Controller sending message to segments: {message}")
            self._set_output_port(message, to_segments)
        elif isinstance(message[1][1], SwitchAction): 
            self.logger.debug(f"Controller sending message to switches: {message}")
            self._set_output_port(message, to_switches)
        elif isinstance(message[1][1], BayAction):
            self.logger.debug(f"Controller sending message to bays: {message}")
            self._set_output_port(message, to_bayes)
        else:
            raise Exception(f"Controller error: no action to be performed {message}")

        if self.messages:
            self.logger.debug(f"Messages still in queue: {self.messages}, {self.dl_status}, {self.belt_status["L"]}")
            message_to_send.schedule(int(len(self.messages) + 1))
    =}

    ############################### CONTROL REACTIONS ##############################
    method _check_interchange_status(switches){=
        '''
        check if all the switches involved in the interchange are free
            switches: list of switches involved in the interchange
            return: True if all the switches are free, False otherwise
        '''
        return all(self.belt_status[switch] == True for switch in switches)
    =}
    method lock_positions(pos, act, switches, stop){=
        '''
        update the status of the switches involved in the action
            pos: position of the pallet in the interchange (InterchangeInputs)
            act: action to be performed by the pallet (SwitchAction)
            switches: list of switches involved in the interchange       
        '''

        if act == SwitchAction.advance:
            if pos == InterchangeInputs.UPPER_SEGMENT:
                self.belt_status[switches[0]] = False
                return 0
            elif pos == InterchangeInputs.LOWER_SEGMENT:
                self.belt_status[switches[1]] = False
                return 0
            elif pos == InterchangeInputs.BAY:
                self.belt_status[switches[0]] = False
                return 0
        elif act == SwitchAction.go_to_bay:
            if pos == InterchangeInputs.UPPER_SEGMENT:
                self.belt_status[switches[0]] = False
                return 0
        
        stop[0] = True
        for switch in switches:
            self.belt_status[switch] = False
    =}
    method take_decision_over_interchange(switch_list, stop, status, bay, upper_segment, lower_segment){=
        for switch in switch_list:
            if switch not in SwitchName.values():
                raise Exception(f"Controller error: invalid switch name {switch}")
        #Update lock on the interchange
        if not self._check_interchange_status(switch_list):
            return None
        else:
            stop[0] = False
        #Get the position of the pallet to be moved
        interchange_pos = schedule_with_priority(status, self.actions)
        if interchange_pos == None:
            return None
        pos = interchange_pos[0]
        pallet_id = status[pos]
        action = self.actions[pallet_id]

        #Check if the action can be performed
        if stop[0] == True:
            return None
        
        elif action == SwitchAction.cross:
            if not self._check_interchange_status(switch_list):
                return None
        elif action == SwitchAction.advance:
            if pos == InterchangeInputs.UPPER_SEGMENT or pos == InterchangeInputs.BAY:
                if self.belt_status[switch_list[0]] == False:
                    return None
            elif pos == InterchangeInputs.LOWER_SEGMENT:
                if self.belt_status[switch_list[1]] == False:
                    return None
        elif action == SwitchAction.go_to_bay:
            if pos == InterchangeInputs.UPPER_SEGMENT:
                if self.belt_status[switch_list[0]] == False:
                    return None
            else: # From lower segment or bay, needs both free
                if not self._check_interchange_status(switch_list):
                    return None

        #Prepare the header of the message
        message = [[], [], []]
        targets = []
        for pos in interchange_pos:
            if pos == InterchangeInputs.BAY:
                targets.append(bay)
                status[pos] = None
                break
            elif pos == InterchangeInputs.LOWER_SEGMENT:
                targets.append(lower_segment)
                status[pos] = None
            elif pos == InterchangeInputs.UPPER_SEGMENT:
                targets.append(upper_segment)
                status[pos] = None

        message[0] = targets
        #If both segments are involved and no stop, advance both
        if len(interchange_pos) == 2 and stop[0] == False:
            message[1] = [ControllerCommand.move, SegmentAction.advance]
            for target in switch_list:                    
                self.belt_status[target] = False
            
            return message
        
        #If only one segment is involved, perform the action
        self.lock_positions(pos, action, switch_list, stop)
        if pos == InterchangeInputs.UPPER_SEGMENT or pos == InterchangeInputs.LOWER_SEGMENT:
            message[1] = [ControllerCommand.move, SegmentAction.advance]
        elif pos == InterchangeInputs.BAY:
            message[1] = [ControllerCommand.move, action]      

        if message[1] == []:
            raise Exception(f"Controller error: no action to be performed")
        return message
    =}
    // @label control_af
    reaction(control_af) -> message_to_send{=
        switch_list = [SwitchName.F.value, SwitchName.A.value]
        if not self._check_interchange_status(switch_list) or self.pallet_destinations[self.lu_bay_status[0]] != BayName.LU.value:
            return None
        else:
            self.af_stop[0] = False
        message = [[BayName.LU.value], [ControllerCommand.move, BayAction.forward], [None]]
        self.belt_status[SwitchName.F.value] = False
        self.belt_status[SwitchName.A.value] = False
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    // @label control_bh
    reaction(control_bh)-> message_to_send{=
        switch_list = [SwitchName.H.value, SwitchName.B.value]
        message = self.take_decision_over_interchange(switch_list, self.bh_stop, self.bh_status, BayName.Bay4_1, SegmentName.Segment_3.value, SegmentName.Segment_5.value)
        if message == None:
            self.logger.debug("No message generated in control_bh")
            return 0

        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    // @label control_ci
    reaction(control_ci)-> message_to_send{=
        switch_list = [SwitchName.I.value, SwitchName.C.value]
        message = self.take_decision_over_interchange(switch_list, self.ci_stop, self.ci_status, BayName.Bay3_1.value, SegmentName.Segment_2.value, SegmentName.Segment_6.value)
        if message == None:
            self.logger.debug("No message generated in control_ci")
            return 0

        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    // @label control_dl
    reaction(control_dl)-> message_to_send{=
        switch_list = [SwitchName.L.value, SwitchName.D.value]
        message = self.take_decision_over_interchange(switch_list, self.dl_stop, self.dl_status, BayName.Bay2_1.value, SegmentName.Segment_1.value, SegmentName.Segment_7.value)
        if message == None:
            self.logger.debug("No message generated in control_dl")
            return 0

        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    // @label control_em
    reaction(control_em)-> message_to_send{=
        switch_list = [SwitchName.M.value, SwitchName.E.value]
        message = self.take_decision_over_interchange(switch_list, self.em_stop, self.em_status, BayName.Bay1_1.value, None, SegmentName.Segment_8.value)
        if message == None:
            self.logger.debug("No message generated in control_em")
            return 0

        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))   
    =}
    // @label control_lu
    reaction(control_lu) -> message_to_send{=
        switch_list = BayName.LU.value
        message = None
        if self.lu_bay_status[0] != 0:
            return 0
        else:
            message = [[], [], []]
            if self.lu_status[InterchangeInputs.UPPER_SEGMENT] == None:
                return 0

            message[0] = [SegmentName.Segment_4.value]
            message[1] = [ControllerCommand.move, SegmentAction.advance]
        if message == None:
            raise Exception(f"Controller error: no action to be performed")
        self.belt_status[BayName.LU.value] = False
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    
    ############################## SEGMENT REACTIONS ##################################
    method handle_segment_event(value, switch_name, status, position, bay_status){=
        if not isinstance(value, (list, tuple)) or len(value) != 2:
            raise Exception(f"Controller error: invalid request format {value}")

        self.logger.debug(f"Controller received segment event {value}")
        event = value[0]
        pallet_id = value[1]
        if not isinstance(event, Events):
            raise Exception(f"Controller error: invalid event {event}")
        if pallet_id != None and pallet_id not in self.pallet_names:
            self.new_pallet_created(pallet_id)

        if event == Events.pallet_released:
            status[position] = pallet_id
            if pallet_id == None:                
                return 0

            self.actions[pallet_id] = calculate_next_action(switch_name.value, self.pallet_destinations[pallet_id], bay_status, pallet_id)

        elif event == Events.pallet_arrived:
            if pallet_id == None:
                raise Exception(f"Controller error: invalid pallet id {pallet_id} for event {event}")

            status[position] = pallet_id
            self.actions[pallet_id] = calculate_next_action(switch_name.value, self.pallet_destinations[pallet_id], bay_status, pallet_id)
    =}
    input segment_5
    // @label segment_ab
    reaction(segment_5) -> control_bh{=
        value = segment_5.value
        self.handle_segment_event(value, SwitchName.B, self.bh_status, InterchangeInputs.LOWER_SEGMENT, self.bay4_status)
        control_bh.schedule(0)        
    =}
    input segment_6
    // @label segment_bc
    reaction(segment_6) -> control_ci{=
        value = segment_6.value
        self.handle_segment_event(value, SwitchName.C, self.ci_status, InterchangeInputs.LOWER_SEGMENT, self.bay3_status)
        control_ci.schedule(0)
    =}
    input segment_7
    // @label segment_cd
    reaction(segment_7) -> control_dl{=
        value = segment_7.value
        self.handle_segment_event(value, SwitchName.D, self.dl_status, InterchangeInputs.LOWER_SEGMENT, self.bay2_status)
        control_dl.schedule(0)
    =}
    input segment_8
    // @label segment_de
    reaction(segment_8) -> control_em{=
        value = segment_8.value
        self.handle_segment_event(value, SwitchName.E, self.em_status, InterchangeInputs.LOWER_SEGMENT, self.bay1_status)
        control_em.schedule(0)
    =}
    input segment_1
    // @label segment_ml
    reaction(segment_1) -> control_dl{=
        value = segment_1.value
        self.handle_segment_event(value, SwitchName.L, self.dl_status, InterchangeInputs.UPPER_SEGMENT, self.bay2_status)
        control_dl.schedule(0)
    =}
    input segment_2
    // @label segment_li
    reaction(segment_2) -> control_ci{=
        value = segment_2.value
        self.handle_segment_event(value, SwitchName.I, self.ci_status, InterchangeInputs.UPPER_SEGMENT, self.bay3_status)
        control_ci.schedule(0)
    =}
    input segment_3
    // @label segment_ih
    reaction(segment_3) -> control_bh{=
        value = segment_3.value
        self.handle_segment_event(value, SwitchName.H, self.bh_status, InterchangeInputs.UPPER_SEGMENT, self.bay4_status)
        control_bh.schedule(0)
    =}
    input segment_4
    // @label segment_hg
    reaction(segment_4) -> control_lu{=
        value = segment_4.value
        event = value[0]
        pallet_id = value[1]
        
        if pallet_id != None and pallet_id not in self.pallet_names:
            self.new_pallet_created(pallet_id)
        self.lu_status[InterchangeInputs.UPPER_SEGMENT] = pallet_id
        if event == Events.pallet_released:            
            if pallet_id == None:                
                return 0            
            
        elif event == Events.pallet_arrived:
            if pallet_id == None:
                raise Exception(f"Controller error: invalid pallet id {pallet_id} for event {event}")

        self.actions[pallet_id] = calculate_next_action(BayName.LU.value, self.pallet_destinations[pallet_id], self.lu_bay_status, pallet_id)
        control_lu.schedule(0)
    =}

    ############################## BAY REACTIONS ##############################
    method _single_switch_bay_event(bay_status, event, pallet_id, bay, status){=
        if event not in Events:
            raise Exception(f"Controller error: invalid event {event} from bay")
        if pallet_id == None:
            raise Exception(f"Controller error: invalid pallet id {pallet_id} from bay")
        
        if pallet_id not in self.pallet_names:
            self.new_pallet_created(pallet_id)        
        
        if event == Events.pallet_arrived:
            if self.pallet_destinations[pallet_id] != bay:
                raise Exception(f"Controller error: pallet {pallet_id} has no destination")
            bay_status[0] = pallet_id  
            
        elif event == Events.pallet_released:
            self.logger.info(f"Controller received bay event {event} from bay {bay}, pallet {pallet_id} released")
            bay_status[0] = 0
            status[InterchangeInputs.BAY] = None  

        elif event == Events.pallet_pending:
            self.logger.info(f"Controller received bay event {event} from bay {bay}, pallet {pallet_id} pending")
            status[InterchangeInputs.BAY] = pallet_id
    =}
    input bay1_request
    // @label message_from_bay_1
    reaction(bay1_request) -> message_to_send, control_em{=
        value = bay1_request.value
        self._single_switch_bay_event(self.bay1_status, value[0], value[1], BayName.Bay1_1.value, self.em_status)
        control_em.schedule(0)
    =}
    input bay5_request
    // @label message_from_bay_5
    reaction(bay5_request) -> message_to_send, control_af, control_lu{=
        value = bay5_request.value
        self._single_switch_bay_event(self.lu_bay_status, value[0], value[1], BayName.LU.value, self.lu_status)
        control_af.schedule(0)
        control_lu.schedule(0)
    =}

    #Multiple switch bay
    method _multiple_switch_bay_event(bay_status, event, pallet_id, bay_name, status, control){=
        if event not in Events:
            raise Exception(f"Controller error: invalid event {event} from bay")
        if pallet_id == None:
            raise Exception(f"Controller error: invalid pallet id {pallet_id} from bay") 
        if pallet_id not in self.pallet_names:
            self.new_pallet_created(pallet_id)
        if bay_name not in BayName.values():
            raise Exception(f"Controller error: invalid bay name {bay_name}")

        bay_pos = int(bay_name[-1])
        bay_status[bay_pos - 1] = pallet_id if event == Events.pallet_arrived else 0
        if event == Events.pallet_arrived or event == Events.pallet_pending:
            #Check if the pallet has the correct destination
            self.logger.debug(f"Controller received bay event {event} from bay {bay_name},")
            if self.pallet_destinations[pallet_id] == bay_name:
                return 0
            self.actions[pallet_id] = calculate_next_action(bay_name, self.pallet_destinations[pallet_id], bay_status, pallet_id)
            return [[bay_name], [ControllerCommand.move, self.actions[pallet_id]], [pallet_id]]

        elif event == Events.pallet_released:
            self.logger.debug(f"Controller received bay event {event} from bay {bay_name}, pallet {pallet_id} released")
            if bay_pos == 1:
                status[InterchangeInputs.BAY] = None
    =}
    input bay2_request
    // @label message_from_bay_2
    reaction(bay2_request) -> message_to_send, control_dl{=
        value = bay2_request.value
        message = self._multiple_switch_bay_event(self.bay2_status, value[0], value[1], value[2], self.dl_status, control_dl)
        if message == None:
            return 0
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    input bay3_request
    // @label message_from_bay_3
    reaction(bay3_request) -> message_to_send, control_ci{=
        value = bay3_request.value
        message = self._multiple_switch_bay_event(self.bay3_status, value[0], value[1], value[2], self.ci_status, control_ci)
        if message == None:
            return 0
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    input bay4_request
    // @label message_from_bay_4
    reaction(bay4_request) -> message_to_send, control_bh{=
        value = bay4_request.value
        message = self._multiple_switch_bay_event(self.bay4_status, value[0], value[1], value[2], self.bh_status, control_bh)
        if message == None:
            return 0
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    
    ############################## SWITCH REACTIONS ##############################
    method _prepare_message_for_switch(value, switch, control, stop, bay_status){=
        event = value[0]
        if event not in Events:
            raise Exception(f"Controller error: invalid event {event} from switch {switch}")
        pallet_id = value[1]
        message = None
        self.logger.debug(f"Controller handling switch {switch} event {value}, current belt status: {control}")
        if event == Events.pallet_arrived:
            if pallet_id not in self.pallet_names:
                self.new_pallet_created(pallet_id)

            self.logger.debug(f"Controller received switch event {value} from switch {switch}")
            self.belt_status[switch] = False
            port = value[2]
            
            #Handle the case where pallet receives a new destination while on the switch
            if port not in SwitchPort:
                raise Exception(f"Controller error: invalid port {port} from switch {switch}")
            if port == SwitchPort.Interchange and self.actions[pallet_id] == SwitchAction.cross:
                self.actions[pallet_id] = calculate_next_action(switch, self.pallet_destinations[pallet_id], bay_status, pallet_id)
                if self.actions[pallet_id] == SwitchAction.cross:
                    self.actions[pallet_id] = SwitchAction.advance
            elif port == SwitchPort.Bay and stop[0] == True:
                self.actions[pallet_id] = SwitchAction.cross
            elif port == SwitchPort.Bay and self.actions[pallet_id] == SwitchAction.go_to_bay:
                self.actions[pallet_id] = SwitchAction.advance
            else:
                self.actions[pallet_id] = calculate_next_action(switch, self.pallet_destinations[pallet_id], bay_status, pallet_id)
            
            message = [[switch], [ControllerCommand.move, self.actions[pallet_id]], [None]]

        elif event == Events.pallet_released:
            self.logger.debug(f"Controller received switch event {value} from switch {switch}")
            self.belt_status[switch] = True
            if control != None:
                control.schedule(0)

        return message
    =}
    input switch_a_request
    // @label switch_a
    reaction (switch_a_request)-> message_to_send, control_af{=
        value = switch_a_request.value
        message = self._prepare_message_for_switch(value, SwitchName.A.value, control_af, self.af_stop, None)
        if message == None:
            return 0
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    input switch_b_request
    // @label switch_b
    reaction (switch_b_request) -> message_to_send, control_bh{=
        value = switch_b_request.value
        message = self._prepare_message_for_switch(value, SwitchName.B.value, control_bh, self.bh_stop, self.bay4_status)
        if message == None:
            return 0
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    input switch_c_request
    // @label switch_c
    reaction (switch_c_request) -> message_to_send, control_ci{=
        value = switch_c_request.value
        message = self._prepare_message_for_switch(value, SwitchName.C.value, control_ci, self.ci_stop, self.bay3_status)
        if message == None:
            return 0
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    input switch_d_request
    // @label switch_d
    reaction (switch_d_request) -> message_to_send, control_dl{=
        value = switch_d_request.value
        message = self._prepare_message_for_switch(value, SwitchName.D.value, control_dl, self.dl_stop, self.bay2_status)
        if message == None:
            return 0
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    input switch_e_request
    // @label switch_e
    reaction (switch_e_request) -> message_to_send, control_em{=
        value = switch_e_request.value
        message = self._prepare_message_for_switch(value, SwitchName.E.value, control_em, self.em_stop, self.bay1_status)
        if message == None:
            return 0
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    input switch_f_request
    // @label switch_f
    reaction (switch_f_request) -> message_to_send, control_af{=
        value = switch_f_request.value
        message = self._prepare_message_for_switch(value, SwitchName.F.value, None, self.af_stop, None)
        if message == None:
            return 0
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    input switch_h_request
    // @label switch_h
    reaction (switch_h_request) -> message_to_send, control_bh{=
        value = switch_h_request.value
        message = self._prepare_message_for_switch(value, SwitchName.H.value, control_bh, self.bh_stop, self.bay4_status)
        if message == None:
            return 0
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    input switch_i_request
    // @label switch_i
    reaction (switch_i_request) -> message_to_send, control_ci{=
        value = switch_i_request.value
        message = self._prepare_message_for_switch(value, SwitchName.I.value, control_ci, self.ci_stop, self.bay3_status)
        if message == None:
            return 0
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    input switch_l_request
    // @label switch_l
    reaction (switch_l_request) -> message_to_send, control_dl{=
        value = switch_l_request.value
        message = self._prepare_message_for_switch(value, SwitchName.L.value, control_dl, self.dl_stop, self.bay2_status)
        if message == None:
            return 0
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    input switch_m_request
    // @label switch_m
    reaction (switch_m_request) -> message_to_send, control_em{=
        value = switch_m_request.value
        message = self._prepare_message_for_switch(value, SwitchName.M.value, control_em, self.em_stop, self.bay1_status)
        if message == None:
            return 0
        self.messages.append(message)
        message_to_send.schedule(int(len(self.messages) + 1))
    =}
    
    ############################## FROST ##############################
    method _prepare_message(destination){=  
        key = BayName.get_key(destination)
        if key == None:
            raise Exception(f"Controller error: invalid destination {destination}")      
        message = [[key], [ControllerCommand.release, BayAction.none], [None]]
        return message
    =}
    method _get_pallet_position(palletNum){=
        if palletNum == self.bay1_status:
            return BayName.Bay1_1.value
        elif palletNum == self.lu_bay_status:
            return BayName.LU.value
        for i in range(1, 4):
            if palletNum == self.bay4_status[i-2]:
                return BayName(f"Bay{i+1}_1").value
            elif palletNum == self.bay3_status[i-2]:
                return BayName(f"Bay{i+1}_2").value
            elif palletNum == self.bay2_status[i-2]:
                return BayName(f"Bay{i+1}_3").value
        return "0"
    =}
    // @label from_frost
    reaction(from_frost)-> message_to_send{=
        palletNum = from_frost.value[0]
        destination = from_frost.value[1]
         # Validate palletNum and destination
        if palletNum not in self.pallet_names:
            raise Exception(f"Controller error: pallet {palletNum} not recognized")       
        if destination not in BayName.values():
            raise Exception(f"Controller error: invalid destination {destination} for pallet {palletNum}")

        self.pallet_destinations[palletNum] = destination  
        position = self._get_pallet_position(palletNum)
        self.logger.info(f"Pallet destinations: {self.pallet_destinations}")
        if position != "0":
            self.messages.append(self._prepare_message(destination))
            message_to_send.schedule(int(len(self.messages) + 1))        
    =}

}